
import numpy as np
import logging
import os
from aiogram import Bot, Dispatcher, types
from aiogram.utils import executor

# =========================================================================
# 1. –ù–ê–°–¢–†–û–ô–ö–ò –ò –ö–û–ù–°–¢–ê–ù–¢–´
# =========================================================================

# !!! –í–°–¢–ê–í–¨–¢–ï –°–Æ–î–ê –í–ê–® –¢–û–ö–ï–ù !!!
API_TOKEN = os.getenv('BOT_TOKEN')

# –õ–∏–º–∏—Ç—ã –¥–ª—è –æ—Å–µ–π (–≤ –≥—Ä–∞–¥—É—Å–∞—Ö)
A_MIN, A_MAX = -120.0, 120.0
B_MIN, B_MAX = -120.0, 120.0

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# =========================================================================
# 2. –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê "BC" (B - –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ Y)
# –ú–æ–¥–µ–ª—å: M = R_Z(C) * R_Y(B)
# =========================================================================

def calculate_ijk_from_bc_zxz(B, C):
    """
    –ü–†–Ø–ú–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (BC -> IJK, ZXZ)
    –ú–æ–¥–µ–ª—å: M = R_Z(C) * R_Y(B)
    """
    B_rad = np.radians(B)
    C_rad = np.radians(C)
    
    # –≠–ª–µ–º–µ–Ω—Ç—ã –º–∞—Ç—Ä–∏—Ü—ã —Å—Ç–∞–Ω–∫–∞ M = R_Z(C) * R_Y(B)
    m13 = np.cos(C_rad) * np.sin(B_rad)
    m23 = np.sin(C_rad) * np.sin(B_rad)
    m31 = -np.sin(B_rad)
    m32 = 0.0
    m33 = np.cos(B_rad)
    
    # –£–≥–æ–ª J (–∏–∑ m33)
    J_rad = np.arccos(m33)
    J = np.degrees(J_rad)
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Gimbal Lock (J=0 –∏–ª–∏ 180)
    if np.isclose(np.sin(J_rad), 0.0):
        I = np.degrees(np.arctan2(np.sin(C_rad), np.cos(C_rad))) # I = C
        K = 0.0
    else:
        # –£–≥–æ–ª I (–∏–∑ m13, m23)
        sin_I = m13 / np.sin(J_rad)
        cos_I = -m23 / np.sin(J_rad)
        I = np.degrees(np.arctan2(sin_I, cos_I))
        
        # –£–≥–æ–ª K (–∏–∑ m31, m32)
        sin_K = m31 / np.sin(J_rad)
        cos_K = m32 / np.sin(J_rad)
        K = np.degrees(np.arctan2(sin_K, cos_K))
        
    return I, J, K

def calculate_bc_from_ijk_zxz(I, J, K):
    """
    –û–ë–†–ê–¢–ù–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (IJK -> BC, ZXZ)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –î–í–ê —Ä–µ—à–µ–Ω–∏—è.
    """
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≥–ª–∞–≤–Ω—ã–π –∫–æ—Å—Ç—ã–ª—å ZXZ –¥–ª—è —ç—Ç–æ–π –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∏:
    # m32 = sin(J)*cos(K) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 0.
    # –≠—Ç–æ –∑–Ω–∞—á–∏—Ç, K –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 90 –∏–ª–∏ -90 (–µ—Å–ª–∏ J –Ω–µ 0).
    
    # –†–µ—à–µ–Ω–∏–µ 1 (–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç K = -90)
    # B = J
    # C = I - 90
    B1 = J
    C1 = (I - 90.0 + 180) % 360 - 180 # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è C –≤ [-180, 180]

    # –†–µ—à–µ–Ω–∏–µ 2 (–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞ L K = +90)
    # B = -J
    # C = I + 90
    B2 = -J
    C2 = (I + 90.0 + 180) % 360 - 180 # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è C
    
    return (B1, C1), (B2, C2)

# =========================================================================
# 3. –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê "AC" (A - –ø–æ–≤–æ—Ä–æ—Ç –≤–æ–∫—Ä—É–≥ X)
# –ú–æ–¥–µ–ª—å: M = R_Z(C) * R_X(A)
# =========================================================================

def calculate_ijk_from_ac_zxz(A, C):
    """
    –ü–†–Ø–ú–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (AC -> IJK, ZXZ)
    –ú–æ–¥–µ–ª—å: M = R_Z(C) * R_X(A)
    """
    # –î–ª—è —ç—Ç–æ–π –º–æ–¥–µ–ª–∏ M_ZXZ(I,J,K) = R_Z(I) * R_X(J) * R_Z(K)
    # M_AC = R_Z(C) * R_X(A)
    # –ú—ã –∏—â–µ–º I, J, K —Ç–∞–∫–∏–µ, —á—Ç–æ:
    # R_Z(I) * R_X(J) * R_Z(K) = R_Z(C) * R_X(A)
    # –≠—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ, –µ—Å–ª–∏ I=C, J=A, K=0.
    I = C
    J = A
    K = 0.0
    return I, J, K

def calculate_ac_from_ijk_zxz(I, J, K):
    """
    –û–ë–†–ê–¢–ù–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (IJK -> AC, ZXZ)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –î–í–ê —Ä–µ—à–µ–Ω–∏—è.
    """
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Å—Ç—ã–ª—å ZXZ –¥–ª—è —ç—Ç–æ–π –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∏:
    # m31 = sin(J)*sin(K) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 0.
    # –≠—Ç–æ –∑–Ω–∞—á–∏—Ç, K –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 0 –∏–ª–∏ 180 (–µ—Å–ª–∏ J –Ω–µ 0).

    # –†–µ—à–µ–Ω–∏–µ 1 (–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç K = 0)
    # A = J
    # C = I
    A1 = J
    C1 = (I + 180) % 360 - 180 # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è

    # –†–µ—à–µ–Ω–∏–µ 2 (–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç K = 180)
    # A = -J
    # C = I + 180
    A2 = -J
    C2 = (I + 180.0 + 180) % 360 - 180 # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    
    return (A1, C1), (A2, C2)

# =========================================================================
# 4. –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ë–û–¢–ê
# =========================================================================

@dp.message_handler(commands=['start', 'help'])
async def send_welcome(message: types.Message):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏."""
    await message.reply(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç-–∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —É–≥–ª–æ–≤ ZXZ.\n\n"
        f"**–õ–∏–º–∏—Ç—ã:**\n"
        f"–û—Å—å A (–≤–æ–∫—Ä—É–≥ X): [{A_MIN}¬∞, {A_MAX}¬∞]\n"
        f"–û—Å—å B (–≤–æ–∫—Ä—É–≥ Y): [{B_MIN}¬∞, {B_MAX}¬∞]\n\n"
        "**–§–æ—Ä–º–∞—Ç—ã –∫–æ–º–∞–Ω–¥ (ZXZ):**\n\n"
        "**1. –ü—Ä—è–º–∞—è (–û—Å–∏ -> IJK):**\n"
        "  `AC <A> <C>` (–Ω–∞–ø—Ä. `AC 90 180`)\n"
        "  `BC <B> <C>` (–Ω–∞–ø—Ä. `BC 90 180`)\n\n"
        "**2. –û–±—Ä–∞—Ç–Ω–∞—è (IJK -> –û—Å–∏):**\n"
        "  `AC <I> <J> <K>` (–Ω–∞–ø—Ä. `AC 45 30 0`)\n"
        "  `BC <I> <J> <K>` (–Ω–∞–ø—Ä. `BC 178 36 -90`)\n\n"
        "–ë–æ—Ç –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∂–µ—Ç –¥–≤–∞ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π –∫–∏–Ω–µ–º–∞—Ç–∏–∫–∏.",
        parse_mode=types.ParseMode.MARKDOWN
    )

def check_limit(value, min_val, max_val):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤ –ª–∏–º–∏—Ç–µ –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Emoji."""
    if min_val <= value <= max_val:
        return "‚úÖ (–í –ª–∏–º–∏—Ç–µ)"
    return "‚ùå (–í–ù–ï –ª–∏–º–∏—Ç–∞)"

async def format_inverse_response(solutions, axis_names, limits):
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –¥–ª—è –¥–≤—É—Ö —Ä–µ—à–µ–Ω–∏–π."""
    name_A, name_C = axis_names
    min_val, max_val = limits
    
    (A1, C1), (A2, C2) = solutions
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
    limit_check1 = check_limit(A1, min_val, max_val)
    limit_check2 = check_limit(A2, min_val, max_val)
    
    response = (
        f"**–†–∞—Å—Å—á–∏—Ç–∞–Ω–æ 2 –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—à–µ–Ω–∏—è:**\n\n"
        f"**–†–µ—à–µ–Ω–∏–µ 1 (–û–±—ã—á–Ω–æ –¥–ª—è K=0 –∏–ª–∏ K=-90):**\n"
        f"  {name_A}: `{A1:.3f}¬∞` {limit_check1}\n"
        f"  {name_C}: `{C1:.3f}¬∞`\n\n"
        f"**–†–µ—à–µ–Ω–∏–µ 2 (–û–±—ã—á–Ω–æ –¥–ª—è K=180 –∏–ª–∏ K=90):**\n"
        f"  {name_A}: `{A2:.3f}¬∞` {limit_check2}\n"
        f"  {name_C}: `{C2:.3f}¬∞`"
    )
    return response

@dp.message_handler()
async def handle_calculations(message: types.Message):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∫–æ–º–∞–Ω–¥—ã —Ä–∞—Å—á–µ—Ç–∞."""
    
    parts = message.text.upper().split()
    response = "‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π."
    
    if len(parts) < 3:
        await message.reply(response)
        return

    mode = parts[0]
    
    try:
        # ---------------------------------------------------
        # –ü–†–Ø–ú–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (–û—Å–∏ -> IJK), 3 –∞—Ä–≥—É–º–µ–Ω—Ç–∞
        # ---------------------------------------------------
        if len(parts) == 3:
            val1, val2 = map(float, parts[1:])
            
            if mode == 'AC':
                if not (A_MIN <= val1 <= A_MAX):
                    response = f"‚ö†Ô∏è –û—à–∏–±–∫–∞: –£–≥–æ–ª A={val1} –≤–Ω–µ –ª–∏–º–∏—Ç–æ–≤ [{A_MIN}, {A_MAX}]."
                else:
                    I, J, K = calculate_ijk_from_ac_zxz(val1, val2)
                    response = (f"**–†–µ–∑—É–ª—å—Ç–∞—Ç AC ({val1}¬∞, {val2}¬∞) -> IJK (ZXZ):**\n"
                                f"  I: `{I:.3f}¬∞`\n"
                                f"  J: `{J:.3f}¬∞`\n"
                                f"  K: `{K:.3f}¬∞`")
            
            elif mode == 'BC':
                if not (B_MIN <= val1 <= B_MAX):
                    response = f"‚ö†Ô∏è –û—à–∏–±–∫–∞: –£–≥–æ–ª B={val1} –≤–Ω–µ –ª–∏–º–∏—Ç–æ–≤ [{B_MIN}, {B_MAX}]."
                else:
                    I, J, K = calculate_ijk_from_bc_zxz(val1, val2)
                    response = (f"**–†–µ–∑—É–ª—å—Ç–∞—Ç BC ({val1}¬∞, {val2}¬∞) -> IJK (ZXZ):**\n"
                                f"  I: `{I:.3f}¬∞`\n"
                                f"  J: `{J:.3f}¬∞`\n"
                                f"  K: `{K:.3f}¬∞`")
            else:
                response = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'AC' –∏–ª–∏ 'BC'."
        
        # ---------------------------------------------------
        # –û–ë–†–ê–¢–ù–ê–Ø –ö–ò–ù–ï–ú–ê–¢–ò–ö–ê (IJK -> –û—Å–∏), 4 –∞—Ä–≥—É–º–µ–Ω—Ç–∞
        # ---------------------------------------------------
        elif len(parts) == 4:
            I, J, K = map(float, parts[1:])
            
            if mode == 'AC':
                solutions = calculate_ac_from_ijk_zxz(I, J, K)
                response = await format_inverse_response(solutions, ("A", "C"), (A_MIN, A_MAX))
            
            elif mode == 'BC':
                solutions = calculate_bc_from_ijk_zxz(I, J, K)
                response = await format_inverse_response(solutions, ("B", "C"), (B_MIN, B_MAX))
            
            else:
                response = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'AC' –∏–ª–∏ 'BC'."

    except ValueError:
        response = "‚ö†Ô∏è –û—à–∏–±–∫–∞: –í—Å–µ —É–≥–ª—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏."
    except Exception as e:
        logging.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: {e}") 
        response = f"‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞: {e}"

    await message.reply(response, parse_mode=types.ParseMode.MARKDOWN)

# =========================================================================
# 5. –ó–ê–ü–£–°–ö –ë–û–¢–ê
# =========================================================================

if __name__ == '__main__':
    logging.info("Starting bot...")
    executor.start_polling(dp, skip_updates=True)



